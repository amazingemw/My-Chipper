module injector (
northad,
southad,
eastad,
westad,
localad,
clk,
nad,
sad,
ead,
wad,
/*localndir,
localsdir,
localedir,
localwdir*/
);

input [9:0] northad;
input [9:0] southad;
input [9:0] eastad;
input [9:0] westad;
input [9:0] localad;
input clk;
output [9:0] nad;
output [9:0] sad;
output [9:0] ead;
output [9:0] wad;


/*output [4:0] localndir;
output [4:0] localsdir;
output [4:0] localedir;
output [4:0] localwdir;*/

wire [9:0] northad;
wire [9:0] southad;
wire [9:0] westad;
wire [9:0] eastad;           //0 is from east, 1 from west, 2 from north, 3 from south 
wire [9:0] localad;
wire clk;
reg [9:0] nad;               //0 is to east, 1 to west, 2 to north, 3 to south 
reg [9:0] sad;
reg [9:0] ead;
reg [9:0] wad;

reg [2:0] localndir;         //direction from router
reg [2:0] localsdir;
reg [2:0] localedir;
reg [2:0] localwdir;

reg nvalid=0;                  //If the channel contains valid data
reg svalid=0;
reg evalid=0;
reg wvalid=0;


initial begin
nad [5:0] = northad [5:0];   //encoding the destination address in o/p
sad [5:0] = southad [5:0];  
ead [5:0] = eastad [5:0];
wad [5:0] = westad [5:0];

nad [9] = northad [9];       //encoding the golden bit in output
sad [9] = southad [9];       //from i/p
ead [9] = eastad [9];               
wad [9] = westad [9];              
                                      
localndir = 3'b111;  
localsdir = 3'b111;        
localedir = 3'b111;               
localwdir = 3'b111;               
  			     
if(nad[5:0] !== 6'bz)       //checking validity of data in channel 
nvalid = 1;                  //and setting validity bits for each channel
if(sad[5:0] !== 6'bz)
svalid = 1;
if(ead[5:0] !== 6'bz)
evalid = 1;
if(wad[5:0] !== 6'bz)
wvalid = 1;
end

always @(posedge clk)
begin
 directandfill(northad[5:0], localad, nad[5:0], localndir);     //function to fill a blank channel
 directandfill(southad[5:0], localad, sad[5:0], localsdir);     //with a local channel
 directandfill(eastad[5:0], localad, ead[5:0], localedir);
 directandfill(westad[5:0], localad, wad[5:0], localwdir);
end


reg [2:0] col;    //global variables for task directandfill
reg [2:0] row;

task directandfill;
	input [5:0] addr;
	input [5:0] localad;
	output [5:0] adr;
	output [2:0] dir;

	begin 
	
        	if (addr === 6'bz) begin
			adr = localad;
	 		row = localad[5:3];  
			col = localad[2:0]; 	
		end else begin
			adr = addr;
			row = addr[5:3];  
			col = addr[2:0]; 
		end
	
        	if ( col > 3'b100) begin
			dir = 3'b000;             	//EAST
       		end
       		if ( col < 3'b100) begin
			dir = 5'b001;             	//WEST
       		end 
		if ( col === 3'b100) begin
			if ( row > 3'b100) begin
				dir = 5'b010;           //NORTH
       			end
			if ( row < 3'b100) begin
				dir = 5'b011;           //SOUTH
      			end
			if ( row === 3'b100) begin
				dir = 5'b100; 	        //LOCAL    
			end
       		end
	
	end  //begin's end
endtask

endmodule


